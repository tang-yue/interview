
## 输入url到页面呈现发生了什么

+ DNS 解析：将域名解析成IP地址
+ TCP 连接：TCP 三次握手
+ 发送 HTTP 请求
+ 服务器处理请求并返回 HTTP 报文
+ 浏览器解析渲染页面
+ 断开连接：TCP 四次挥手

[url到render详解版](./url-to-render.md)

[参考文章](https://zhuanlan.zhihu.com/p/57895541)

[参考文章](https://github.com/impeiran/Blog/issues/3)

## 浏览器的渲染过程

1、根据HTML 标记并构建DOM树
2、根据CSS构建CSS树 (CSSOM)
3、将两颗树合并成一棵渲染树 (render tree)
4、layout 布局 (文档流，盒模型，计算大小或位置等)
5、paint 绘制 (边框颜色，背景颜色，阴影等绘制)
6、componse 合成 (根据层叠关系展示画面)

[参考文章](https://juejin.im/post/6844904147779584007)

## 浏览器的回流与重绘

### 回流(Reflow)

回流必将引起重绘，重绘不一定会引起回流。

当Render Tree 中部分或全部元素的尺寸，结构，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
 
### 重绘(Repaint)

当页面中元素样式的改变并不影响它在文档流中的位置时，(例如：color、background-color、visibility 等)，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

### 性能影响

回流比重绘的代价要更高

现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列,把所有引起回流和重绘的操作放入队列中,如果队列中的任务数量或者时间间隔达到一个阈值的,浏览器就会将队列清空,进行一次批处理,这样可以把多次回流和重绘变成一次。

### 如何避免

css方面

+ 避免使用table布局

+ 避免设置多层内联样式

js方面

+ 避免频繁操作样式

+ 避免频繁操作DOM


[参考文章](https://juejin.im/post/6844904160329285639)

## Event Loop

js 是 单线程的， 有了Event Loop 的加持， JS 才能非阻塞地运行。

同步任务指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
异步任务指的是：不进入主线程，而是进入任务队列，通过Event Loop 机制等待合适的时间调用

流程图如下：

![event-loop](https://tang-yue.github.io/interview/promise/event-loop.jpg)

总结：

先执行宏任务，后执行微任务，同步任务立即执行，异步任务将回调函数放入Event Queue等待下一轮事件循环

具体流程：

1、执行全局Script 代码，这些代码中有同步语句或异步语句，遇到同步语句直接执行，异步语句放入宏任务或微任务的队列。

2、全局 Script 代码执行完毕后，调用栈 Stack 会清空

3、从微任务中取出位于队首的回调任务，放入调用栈Stack 中执行，执行完成后，微任务队列长度减一

4、继续取出位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到把微任务队列中的所有任务都执行完毕，注意，如果在执行微任务过程中，又产生了新的微任务，那么会加入到微任务队列的尾部，也会在这个周期被执行

5、当微任务队列中所有任务都执行完毕后，此时微任务队列为空，调用栈Stack 也会为空

6、取出 宏任务中的队首的任务放入 Stack 中执行

7、执行完毕后，调用栈 Stack 为空

8、重复第3～7个步骤

[参考文章](https://zhuanlan.zhihu.com/p/165149415)

[Node.js 事件循环](https://zhuanlan.zhihu.com/p/161557376)

## node 和浏览器事件循环有何不同

事件循环同样运行在单线程环境下，JavaScript的事件循环是依靠浏览器实现的，而Node作为另一种运行时，事件循环由底层的libuv实现。

将事件循环分成了6个阶段，其中每个阶段都维护着一个回调函数的队列，在不同的阶段，事件循环会处理不同类型的事件，每次都是顺序执行。

```js
while(true) {
  uv__run_timers();   // Timers：用来处理setTimeOut() 和 setInterval()的回调。

  uv__run_pending(loop);  // I/O callbacks：大多数的回调方法在这个阶段执行，除了timers、close 和 setImmediate 事件的回调
  
  uv__run_idle();   // idle，prepare：仅仅在内部使用，我们不管它

  uv__io_poll();   // Poll：轮询，不断检查有没有新的IO 事件，事件循环可能会在这里阻塞

  uv__run_check(); // Check：处理 setImmediate() 事件的回调

  uv__run_closing_handles(); // Close: 处理一些 close 相关的事件，例如 socket.on 
}
```

**1．timers**

从名字就可以看出来，这个阶段主要用来处理定时器相关的回调，当一个定时器超时后，一个事件就会加入到队列中，事件循环会跳转至这个阶段执行对应的回调函数。

定时器的回调会在触发后尽可能早（as early as they can）地被调用，这表示实际的延时可能会比定时器规定的时间要长。

如果事件循环，此时正在执行一个比较耗时的 callback，例如处理一个比较耗时的循环，那么定时器的回调只能等当前回调执行结束了才能被执行，即被阻塞。事实上，timers 阶段的执行受到 poll 阶段控制。

**2．IO callbacks 阶段**

官方文档对这个阶段的描述为除了 timers、 setImmediate，以及 close 操作之外的大多数的回调方法都位于这个阶段执行。事实上从源码来看，该阶段只是用来执行 pending callback，例如一个 TCP socket 执行出现了错误，在一些*nix 系统下可能希望稍后再处理这里的错误，那么这个回调就会放在 IO callback 阶段来执行。

一些常见的回调，例如 fs.readFile 的回调是放在 poll 阶段来执行的。

**3．poll 阶段**

poll 阶段的主要任务是等待新的事件出现（该阶段使用 epoll 来获取新的事件），如果没有，事件循环可能会在此阻塞（关于是否在 poll 阶段阻塞以及阻塞多长时间，libuv 有一些复杂的判定方法，这里不作深究，如果读者有兴趣，可以参考 libuv 源码文件 src/unix/core.c 下的 uv_run 方法，该方法是事件循环的核心方法）。

这些事件对应的回调方法可能位于 timers 阶段（如果定义了定时器），也可能是 check 阶段（设置了 setImmediate 方法）。

Poll 阶段主要有两个步骤如下：

（1）如果有到期的定时器，那么就执行定时器的回调方法。

（2）处理 poll 阶段对应的事件队列（以下简称 poll 队列）里的事件。

当事件循环到达 poll 阶段时，如果这时没有要处理的定时器的回调方法，则会进行下面的判断：

（1）如果 poll 队列不为空，则事件循环会按照顺序遍历执行队列中的回调函数，这个过程是同步的。

（2）如果 poll 队列为空，会接着进行如下判断：

如果当前代码定义了 setImmediate 方法，事件循环会离开 poll 阶段，然后进入 check 阶段去执行 setImmediate 方法定义的回调方法。
如果当前代码没有定义 setImmediate 方法，那么事件循环可能会进入等待状态，并等待新的事件出现，这也是该阶段为什么会被命名为 poll（轮询）的原因。此外，还会不断检查是否有相关的定时器超时，如果有，就会跳转到 timers 阶段，然后执行对应的回调。

**4．check 阶段**

setImmediate 是一个特殊的定时器方法，它占据了事件循环的一个阶段，整个 check 阶段就是为 setImmediate 方法而设置的。

一般情况下，当事件循环到达 poll 阶段后，就会检查当前代码是否调用了 setImmediate，但如果一个回调函数是被 setImmediate 方法调用的，事件循环就会跳出 poll 阶段进而进入 check 阶段。

**5．close 阶段**

如果一个 socket 或者一个句柄被关闭，那么就会产生一个 close 事件，该事件会被加入到对应的队列中。close 阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。

看完了上面的描述，我们明白了 Node 中的事件循环是分阶段处理的，对于每一阶段来说，处理事件队列中的事件就是执行对应的回调方法，每一阶段的事件循环都对应着不同的队列。

在 Node 中，事件队列不止一个，定时器相关的事件和磁盘 IO 产生的事件需要不同的处理方式，如果把所有的事件都放到一个队列里，势必要增加许多类似 switch/case 的代码；那样的话倒不如将不同类型的事件归类到不同的事件队列里，然后一层层地遍历下来，如果当中出现了新的事件，就进行相应的处理。

为了更好地理解 Node 中的事件循环，以一段代码为例来配合说明：

```js
var fs = require('fs');

var timeoutScheduled = Date.now();

setTimeout(function() {
  
})

// 待完续
```

上面代码改编自官方文档中的一个例子，讲述事件循环不同过程的处理步骤。这段代码的逻辑很简单，包含了 readfile 和 timer 两个异步操作。

我们来观察这段代码的执行过程，代码开始运行后，事件循环也开始运作了。

首先检查 timers，然而 timers 对应的事件队列目前还为空（100ms 后才会有事件产生），事件循环向后执行到了 poll 阶段，到目前为止还没有事件出现，由于代码中没有定义 setImmediate 操作，事件循环便在此一直等待新的事件出现。

直到 95ms 后（假设 readFile 耗费的时间为 95ms，实际上可能比这个时间长或短一些），readFile 读取文件完毕，产生了一个事件，加入到了 poll 这一队列中，此时事件循环将该队列中的事件取出，准备执行之后的 callback（此时 err 和 data 的值已经就绪），readFile 的回调方法什么都没做，只是暂停了 10ms。

事件循环本身也被阻塞 10ms，按照通常的思维，95ms+10ms=105ms>100ms，timers 队列中的事件已经就绪，应该先执行对应的回调方法才是，然而由于事件循环也是单线程运行的，因此也会停止 10ms，如果 readFile 的回调函数中包含了一个死循环，那么整个事件循环都会被阻塞，setTimeout 的回调永远不会执行。

readFile 的回调完成后，事件循环切换到 timers 阶段，接着取出 timers 队列中的事件执行对应的回调方法。

node 和浏览器事件循环的主要区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。

[参考新时期的Node.js入门]

## 浏览器安全

### XSS攻击

#### 什么是XSS攻击

  XSS 攻击：跨站脚本攻击，是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

#### 危害

  1、窃取 Cookie 信息

  2、监听用户行为

  3、修改DOM

  4、在页面内生成浮窗广告

#### 阻止 XSS 攻击的策略

1、服务器对输入脚本进行过滤或转码
2、充分利用 CSP
  + 限制加载其他域下的资源文件
  + 禁止向第三方域提交数据
  + 禁止执行内联脚本和未授权的脚本

3、使用 HttpOnly 属性

用 HttpOnly 标记的Cookie 只能使用在 HTTP 请求过程中，所以无法通过 Javascript 来读取这段Cookie。

4、添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，增大XSS攻击的难度

为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。

### CSRF攻击

#### 什么是CSRF攻击

CSRF 攻击，又称为 “跨站请求伪造” 就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。

#### 三种攻击方式

1、自动发起Get请求

2、自动发起 POST 请求

3、引诱用户点击链接

比如用户填写

#### 如何防止 CSRF 攻击

发起CSRF攻击的三个必要条件

1、第一个，目标站点一定要有CSRF漏洞

2、第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态

3、第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛

#### 要让服务器避免遭受到CSRF攻击，有哪些途径

1、利用好 Cookie 的 SameSite 属性   即，是从第三方站点发起的请求，需要浏览器禁止发送某些关键Cookie数据到服务器，如果是同一个站点发起的请求，需要保证
Cookie 数据正常发送

2、验证请求的来源站点

如果是第三方站点，服务器禁止来自第三方站点的请求，优先判断 Origin (只包含了域名信息)，如果请求头中没有包含Origin 属性，再根据实际情况判断是否使用Referer 值

3、CSRF Token

在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token  其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。
在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该Token是否合法。

[浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)

## 什么是同源策略

协议、域名 和端口都相同，称两个 URL 同源

### 如何解决跨域问题

1、JSONP 

只是请求了一个js文件并且执行了，而且这种跨域方法只能进行GET请求。

web 页面上调用js文件不受浏览器同源策略的影响，所以通过Script 便签可以进行跨域的请求：

(1) 首先前端先设置好回调函数，并将其作为url的参数。
(2) 服务端接受到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回。
(3) 收到结果后因为是script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。

2、服务端代理

3、反向代理

4、window.name

5、location.hash

6、document.domain

JSONP 和 CORS 的对比

JSONP 只支持GET 请求，和后端配置相应回调函数。 CORS 支持所有类型的HTTP请求
JSONP 的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据

[跨域参考文章](https://github.com/happylindz/blog/issues/3)

## 4、Cookie, LocalStorage 与 SessionStorage

### 三者异同

| 特性         | Cookie     | localStorage  | sessionStorage      | 
| ----------- |:---------------:| -----------:| ----------------: |  
| 数据的生命周期 |  一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效     | 除非被清除，否则永久保存 |  仅在当前会话下有效，关闭页面或浏览器后被清除 | 
| 存放数据大小   |   4k 左右      |     5MB        
| 与服务器端通信 |   每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题    |  仅在客户端（即浏览器）中保存，不参与和服务器的通信     
| 易用性        | 需要程序员自己封装，原生的Cookie 接口不友好                        |  原生接口可以接受，亦可再次封装来对Object和Array 有更好的支持     

### 应用场景

cookie 一般存储 token 信息，不要放太多，因为每个http 请求都会带着Cookie的信息
localStorage   能存储很多信息
sessionStorage 把表单页面拆分成多个子页面，然后按步骤引导用户填写

### 安全性考虑

任何数据都不能放在以上三种中，需要时刻注意是否有代码存在xss注入的风险。
因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有xss的风险，它们就能对你的localStorage 肆意妄为。

## 浏览器缓存

### 浏览器缓存机制

1. 浏览器在加载资源时，先根据这个资源的一些http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。
比如： 某个css 文件，如果浏览器在加载它所在的网页时，这个css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在的服务器；

2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器
会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；

3. 强缓存和协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

### 强缓存

`Cache-Control: max-age=315360000` 这是一个相对时间，在配置缓存的时候，以秒为单位，根据它第一次的请求时间和Cache-Control 设定的有效期，计算出一个资源过期时间。

`Expires`和`Cache-Control`同时存在时，Cache-Control 优先级高于Expires.

Cache-Control 的其他字段

可缓存性：
+ `public`: 表明响应可以被任何对象缓存； 
+ `private`: 响应只能被单个用户缓存，不能作为共享缓存；
+ `no-cahe`: 协商缓存
+ `no-store`: 不缓存

到期：`max-age=<seconds> 设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒）。时间是相对于请求的时间。`

### 协商缓存

+ 【If-Modified-Since，last-modified】 这对 Header 控制缓存

  - 1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header 加上 Last-Modified，表示这个资源在服务器上的最后修改时间。

  - 2、浏览器再次跟服务器请求这个资源时，在request 的header 上加上 If-Modified-Since的 header， 这个就是header的值，就是上一次请求时返回的Last-Modified的值。

  - 3、服务器再次收到资源请求时，根据浏览器传过来的 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化。如果没有变化则返回 304 Not Modified，但不会返回资源内容，如果有变化，就正常返回资源内容。

  - 4、浏览器收到304的响应后，就会从缓存中加载资源。

  - 5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的 Last-Modified 值。

+ 【if-none-match, etag】 这对 header

    相同的原理

Etag 和 Last-Modified 相似，但是 ETag 相对 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改。（因为会存在服务器上资源有变化，但是修改时间却没有变化的情况）

流程图如下：

![browser-cache](https://tang-yue.github.io/interview/browser-works/browser-cache.png)

[参考文章](https://juejin.im/post/6844903672556552205)

### 页面渲染的过程中，执行了哪些事件

1、页面加载开始，首先肯定是先发出加载资源的请求，加载未完成之前，不触发任何事件

2、document加载结束并解析，此时css等其他资源未加载完成

此时 readyState 为 'interactive'，表明document已经load并解析完成，触发readystatechange，然后触发DOMContentLoaded，捎带提一句，此时加载完成且带有defer标记的脚本，会按顺序开始执行

3、css、img 等子资源加载完成之后

此时触发window.load 事件

4、点击关闭标签或者刷新时，会依次触发beforeunload、unload 事件

[浏览器工作原理](https://github.com/yacan8/blog/issues/28)
